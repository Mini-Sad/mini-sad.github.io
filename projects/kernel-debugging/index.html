<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Linux Kernel Debugging &amp; Profiling | Abdoul Kader S. Yahaya </title> <meta name="author" content="Abdoul Kader S. Yahaya"> <meta name="description" content="Investigating kernel-level performance and blocking behavior using tracing and profiling tools."> <meta name="keywords" content="jekyll-theme, academic-website, portfolio-website, ENSIIE, computer-science, student, hpc, high-performance-computing"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://mini-sad.github.io/projects/kernel-debugging/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Abdoul Kader</span> S. Yahaya </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/research/">research </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Linux Kernel Debugging &amp; Profiling</h1> <p class="post-description">Investigating kernel-level performance and blocking behavior using tracing and profiling tools.</p> </header> <article> <h3 id="context-and-motivation">Context and Motivation</h3> <p>Understanding how programs behave at runtime requires more than reading source code or reasoning about APIs. I started this work while learning to debug user-space processes on Linux, using tools such as <code class="language-plaintext highlighter-rouge">ps</code>, <code class="language-plaintext highlighter-rouge">strace</code>, <code class="language-plaintext highlighter-rouge">ltrace</code>, and <code class="language-plaintext highlighter-rouge">gdb</code> to inspect execution flow, system call interactions, and stack behavior. This exposed the gap between expected behavior and what actually happens when a process runs.</p> <p>To go beyond surface-level debugging, I then extended this investigation into kernel space. The motivation was to understand how the operating system executes, schedules, and blocks processes beneath user-visible abstractions. By exploring kernel sources and internal instrumentation, I aimed to observe real execution paths, performance bottlenecks, and blocking conditions that are invisible from user space alone.</p> <p>This project was driven by the desire to connect theory with reality: not just what the system should do, but how and why it behaves the way it does under real workloads.</p> <h3 id="technical-approach">Technical Approach</h3> <p>The work followed a progressive approach, starting from user space and extending into kernel space, in order to understand system behavior across abstraction layers rather than treating the kernel as a black box.</p> <p>I began in user space by observing running processes and their interactions with the operating system. Tools such as <code class="language-plaintext highlighter-rouge">ps</code> and <code class="language-plaintext highlighter-rouge">/proc</code> were used to identify anomalous behavior, including processes consuming excessive CPU time. I then employed <code class="language-plaintext highlighter-rouge">strace</code> and <code class="language-plaintext highlighter-rouge">ltrace</code> to distinguish system calls from library-level function calls, allowing me to quantify syscall usage and understand how user-space tools query kernel state through interfaces such as <code class="language-plaintext highlighter-rouge">/proc</code>.</p> <p>To analyze control flow and memory behavior, I relied on <code class="language-plaintext highlighter-rouge">gdb</code> with debug symbols enabled. This made it possible to inspect stack frames, diagnose segmentation faults caused by stack overflows, and attach to a running process exhibiting an infinite loop. By navigating stack frames and modifying variables directly in memory, I was able to alter program behavior at runtime without recompilation, highlighting the power and risks of low-level debugging.</p> <p>After establishing visibility in user space, I extended the analysis into kernel space to observe execution beyond system call boundaries. I navigated kernel source code using <code class="language-plaintext highlighter-rouge">cscope</code> to locate core structures such as <code class="language-plaintext highlighter-rouge">task_struct</code> and trace the path of system calls through the VFS and filesystem layers. Dynamic Debug was used to activate kernel logs at runtime, while <code class="language-plaintext highlighter-rouge">ftrace</code> allowed precise tracing of function execution for a misbehaving process.</p> <p>To complement tracing, I used <code class="language-plaintext highlighter-rouge">perf</code> to profile CPU usage and identify dominant execution paths, revealing filesystem-specific behavior (e.g., XFS) and syscall hotspots. Finally, I employed <code class="language-plaintext highlighter-rouge">crash</code> to inspect kernel memory and analyze blocked processes, using call stack inspection to determine that processes in an uninterruptible state were waiting on NFS I/O operations.</p> <p>This layered approach-combining observation, tracing, profiling, and memory inspection-made it possible to connect high-level symptoms to low-level kernel mechanisms and understand how real workloads are executed and blocked within the operating system.</p> <h3 id="debugging-and-analysis">Debugging and Analysis</h3> <p>The debugging work focused on identifying abnormal runtime behavior and tracing it back to concrete execution states rather than relying on assumptions about the code. A first recurring pattern was the presence of user-space processes consuming significant CPU time over long periods, indicating potential infinite loops or blocking behavior.</p> <p>In one case, a process named <code class="language-plaintext highlighter-rouge">crazy</code> exhibited sustained CPU usage with no visible progress. Attaching a debugger to the running process revealed that execution was trapped in a loop controlled by a local variable whose value never changed. By inspecting the call stack and local variables at runtime, I identified the precise condition maintaining the loop. Modifying the variable directly in memory immediately altered the program’s behavior and allowed it to terminate cleanly, confirming the diagnosis without recompilation or restart.</p> <p>Beyond individual processes, syscall-level analysis provided a broader view of system behavior. By aggregating syscall statistics, it became clear that filesystem-related calls such as <code class="language-plaintext highlighter-rouge">open</code>, <code class="language-plaintext highlighter-rouge">read</code>, and <code class="language-plaintext highlighter-rouge">close</code> dominated execution time for standard utilities. This observation reinforced the role of the virtual filesystem and <code class="language-plaintext highlighter-rouge">/proc</code> as critical interfaces between user-space tools and kernel data structures, and explained why seemingly simple commands can generate thousands of kernel interactions.</p> <p>In kernel space, analysis shifted toward understanding blocked execution. Processes observed in an uninterruptible state were inspected through kernel memory analysis, revealing that they were waiting on I/O operations rather than actively executing. Call stack inspection showed that these processes were blocked in filesystem paths associated with network-backed storage, explaining both their state and their resistance to standard interruption signals.</p> <p>Across both user space and kernel space, the debugging process relied on correlating symptoms (CPU usage, process state, lack of progress) with concrete execution contexts (stack frames, syscalls, kernel call paths). This made it possible to move from surface-level observations to precise explanations of why processes were running, looping, or blocked.</p> <h3 id="tools-and-instrumentation">Tools and Instrumentation</h3> <p>The investigation relied on a small set of complementary tools, each chosen to provide visibility at a specific level of the system rather than overlapping functionality.</p> <p>At the user-space level, <code class="language-plaintext highlighter-rouge">ps</code> and the <code class="language-plaintext highlighter-rouge">/proc</code> filesystem were used to observe process state, CPU consumption, and runtime characteristics. <code class="language-plaintext highlighter-rouge">strace</code> and <code class="language-plaintext highlighter-rouge">ltrace</code> were then employed to distinguish interactions crossing the user–kernel boundary from those occurring within shared libraries, making it possible to reason about syscall frequency, dominant execution paths, and the cost of filesystem access.</p> <p>For control-flow and memory inspection, <code class="language-plaintext highlighter-rouge">gdb</code> was the primary tool. Compiling programs with debug symbols enabled precise inspection of stack frames, local variables, and execution state. Attaching to live processes allowed runtime diagnosis of infinite loops and made it possible to validate hypotheses by modifying program state directly in memory.</p> <p>In kernel space, static and dynamic instrumentation were combined. <code class="language-plaintext highlighter-rouge">cscope</code> was used to navigate kernel source code and understand the execution path of system calls beyond their user-space entry points. Dynamic Debug enabled selective kernel logging without recompilation, while <code class="language-plaintext highlighter-rouge">ftrace</code> provided fine-grained tracing of function execution to observe kernel behavior in response to specific workloads.</p> <p>To analyze performance and blocking behavior, <code class="language-plaintext highlighter-rouge">perf</code> was used to identify CPU hotspots and dominant kernel functions, and <code class="language-plaintext highlighter-rouge">crash</code> was employed to inspect kernel memory and call stacks for processes in blocked states. Together, these tools enabled correlation between high-level symptoms and low-level kernel mechanisms.</p> <h3 id="challenges-and-limitations">Challenges and Limitations</h3> <p>A recurring challenge throughout the work was that many runtime issues are difficult to observe at the exact moment they occur. In user space, highly active processes could not always be interrupted at a precise syscall boundary, requiring manual interruption and careful navigation of stack frames to reconstruct execution context after the fact.</p> <p>Some tools also produced large volumes of data, making raw output impractical to analyze directly. For example, utilities operating on many processes or file descriptors generated verbose traces that obscured relevant information. This required selective filtering and a focus on specific processes or execution paths to keep analysis tractable.</p> <p>In kernel space, visibility was inherently constrained by the complexity of the execution environment. Tracing and profiling exposed function-level behavior, but interpreting results required cross-referencing multiple sources, including kernel source code and call stacks. Additionally, blocked processes could only be understood indirectly through memory inspection and call path analysis, rather than through direct observation of progress.</p> <p>Finally, the analysis was limited to controlled workloads and debugging scenarios. While the tools provided strong insight into execution behavior, conclusions drawn from these experiments may not generalize directly to all production environments, particularly under different filesystem configurations or I/O workloads.</p> <h3 id="key-learnings">Key Learnings</h3> <p>One of the main takeaways from this work is that understanding program behavior requires observing execution as it actually happens, not as it is intended to happen. Source code alone is insufficient to explain runtime behavior without visibility into stack state, memory layout, and system interactions.</p> <p>The boundary between user space and kernel space emerged as a central concept. Tools such as <code class="language-plaintext highlighter-rouge">/proc</code>, system calls, and tracing mechanisms are not implementation details but core interfaces through which user-space programs interrogate kernel state. Even simple commands can trigger thousands of kernel interactions, making performance and behavior inherently tied to filesystem and kernel design.</p> <p>Another important insight was the practical power of live debugging. Attaching to a running process, inspecting its state, and modifying memory at runtime demonstrated that debugging is not only a post-crash activity but also a dynamic investigative process. This capability is powerful, but it also requires caution, as it bypasses many safety guarantees.</p> <p>In kernel space, the work highlighted how blocking and performance issues often originate far from where symptoms appear. Processes that seem inactive or unresponsive may be correctly waiting on I/O, and understanding this requires correlating process state, call stacks, and kernel execution paths rather than relying on surface-level indicators.</p> <p>Finally, this project reinforced the idea that effective debugging is less about mastering individual tools and more about developing a layered mental model of system execution, from high-level symptoms down to low-level mechanisms.</p> <h3 id="what-i-would-do-differently">What I Would Do Differently</h3> <p>With more time, I would extend this work to larger and more diverse workloads in order to evaluate how the observed behaviors scale under sustained pressure. In particular, comparing local filesystems with different network-backed configurations would provide deeper insight into blocking behavior and performance variability.</p> <p>I would also automate parts of the analysis pipeline to reduce reliance on manual inspection. Aggregating syscall statistics, trace outputs, and profiling data across multiple runs would make it easier to identify recurring patterns and eliminate bias introduced by single observations.</p> <p>Finally, I would complement debugging and tracing with controlled fault injection, deliberately introducing delays or failures to observe how processes and the kernel respond. This would help move from reactive debugging toward a more systematic exploration of system robustness.</p> </article> <h2>References</h2> <div class="publications"> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Abdoul Kader S. Yahaya. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>